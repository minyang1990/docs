# Vibe Coding教程 - 优秀项目&文章篇（一） - 开发调优 - LINUX DO
[Vibe Coding教程 - 优秀项目&文章篇（一） - 开发调优 - LINUX DO](https://linux.do/t/topic/1003788) 

  Vibe Coding教程 - 优秀项目&文章篇（一） - 开发调优 - LINUX DO                                                               

Constants loaded at 2025-10-15T06:44:39.759Z

  

[跳到主要内容](#main-container)

 [![](https://linux.do/uploads/default/original/4X/c/c/d/ccd8c210609d498cbeb3d5201d4c259348447562.png)](/) 

[Vibe Coding教程 - 优秀项目&文章篇（一）](/t/topic/1003788)
===============================================

[开发调优](/c/develop/4)

[人工智能](/tag/人工智能),[软件开发](/tag/软件开发)

*   [社区子系统和元宇宙](https://linux.do/pub/resources "社区子系统和元宇宙")
*   ​

*    ![](https://linux.do/letter_avatar/niyan2025/144/5_c16b2ee14fe83ed9a59fc65fbec00f85.png)
       [ 34 ](# "34 个未读通知") 

*   [话题](/latest "所有话题")
*   [我的帖子](/u/niyan2025/activity "我最近的话题活动")
*   [我的消息](/u/niyan2025/messages "我的个人消息")
*   [关于](/about "关于此网站的更多详细信息")
*   [近期活动](/upcoming-events "近期活动")
*   更多

类别

*   [开发调优](/c/develop/4 "此版块包含开发、测试、调试、部署、优化、安全等方面的内容。")
*   [国产替代](/c/domestic/98 "汇聚中国智造，推动技术自强。")
*   [资源荟萃](/c/resource/14 "包括软件分享、开源仓库、视频课程、书籍等分享。")
*   [网盘资源](/c/resource/cloud-asset/94 "网盘资源专用类别，主帖不限时编辑。")
*   [文档共建](/c/wiki/42 "佬友化身翰林学士，一起来编书了。")
*   [非我莫属](/c/job/27 "学成文武艺，货与帝王家。招聘/求职分类，只能发此类信息。")
*   [读书成诗](/c/reading/32 "跟着佬友们一起在论坛读完一本书是什么体验？")
*   [扬帆起航](/c/startup/46 "扬帆起航，目标是星辰大海！此为推广版块。")
*   [前沿快讯](/c/news/34 "前沿快讯，不出门能知天下事。")
*   [网络记忆](/c/feeds/92 "网络是有记忆的，确信！")
*   [福利羊毛](/c/welfare/36 "正经人谁花那个钱啊～ 此版块供羊毛、抽奖等福利使用。")
*   [搞七捻三](/c/gossip/11 "闲聊吹水的板块。不得讨论政治、色情等违规内容。")
*   [社区孵化](/c/incubator/102 "我的项目能很好地为社区佬友服务。")
*   [运营反馈](/c/feedback/2 "有关此网站、其组织、运作方式以及如何改进的讨论。")
*   [深海幽域](/c/muted/45 "冰山下的深海。帖子不会上信息流、不会被论坛搜索。")
*   [所有类别](/categories)

标签

*   [人工智能](/tag/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD)
*   [公告](/tag/%E5%85%AC%E5%91%8A)
*   [原创](/tag/%E5%8E%9F%E5%88%9B "高质量原创帖子（非AI生成、润色内容，非洗稿、搬运内容）可用。")
*   [快问快答](/tag/%E5%BF%AB%E9%97%AE%E5%BF%AB%E7%AD%94)
*   [抽奖](/tag/%E6%8A%BD%E5%A5%96)
*   [精华神帖](/tag/%E7%B2%BE%E5%8D%8E%E7%A5%9E%E5%B8%96)
*   [集中帖](/tag/%E9%9B%86%E4%B8%AD%E5%B8%96 "这里是一些社区开启的专题集中帖。&lt;br&gt;存在集中帖时，在帖子集中讨论，不要另开新帖。")
*   [所有标签](/tags)

*   [我的消息串](/chat/threads "我的消息串")

频道

*   [常规频道](/chat/c/general/2 "🈲 禁止在聊天频道里发送 打卡 等无意义信息，被举报会喜提 禁言1小时 。")

直接消息

*    [![](https://linux.do/user_avatar/linux.do/xronus/72/130867_2.png)  𝒜𝓃𝒾𝓋𝒾𝓍](/chat/c/%F0%9D%92%9C%F0%9D%93%83%F0%9D%92%BE%F0%9D%93%8B%F0%9D%92%BE%F0%9D%93%8D/32458 "与 𝒜𝓃𝒾𝓋𝒾𝓍 聊天") 
*    [![](https://linux.do/user_avatar/linux.do/huan/72/864820_2.png)  焕昭君](/chat/c/%E7%84%95%E6%98%AD%E5%90%9B/43057 "与 焕昭君 聊天") 
*    [![](https://linux.do/user_avatar/linux.do/wenjuhe/72/672301_2.png)  奇妙进化小河马🦛   ![](https://linux.do/images/emoji/twemoji/hippopotamus.png?v=14)](/chat/c/%E5%A5%87%E5%A6%99%E8%BF%9B%E5%8C%96%E5%B0%8F%E6%B2%B3%E9%A9%AC%F0%9F%A6%9B/45968 "与 奇妙进化小河马🦛 聊天") 
*    [![](https://linux.do/user_avatar/linux.do/daster/72/898540_2.png)  Daster](/chat/c/daster/78035 "与 Daster 聊天") 

聊天

Default

​ ​ ​

**真诚**、**友善**、**团结**、**专业**，共建你我引以为荣之社区。[《常见问题解答》](/faq)

[Vibe Coding教程 - 优秀项目&文章篇（一）](/t/topic/1003788)
===============================================

[开发调优](/c/develop/4)

[人工智能](/tag/人工智能),[软件开发](/tag/软件开发)

您已选择 **0** 个帖子。

全选

取消选择

​

[10月 1 日](/t/topic/1003788/1 "跳到第一个帖子")

1 / 43

10月 2 日

[21 分钟 前](/t/topic/1003788/45)

​

 [![](https://linux.do/user_avatar/linux.do/zhongruan/144/638503_2.png)](/u/zhongruan)  

[钟阮（zhongruan）](/u/zhongruan) [zhongruan](/u/zhongruan) 活跃用户

2

[13 天](/t/topic/1003788?u=niyan2025 "发布日期")

[](#p-9124692-h-1)感谢各位大佬的相关教程，能记住出处的均已标注
========================================

> \[**如用冲突以这两个为准**\]直链网页：[点击访问](https://vibercoding.zxiaoruan.cn/)  
> \[**如用冲突以这两个为准**\]GitHub共建文档： [点击访问](https://github.com/zhongruan0522/vibercoding/)  
> L站合贴：[点击访问](https://linux.do/t/topic/990446)

为什么分多个呢...

[![](https://linux.do/uploads/default/optimized/4X/6/d/2/6d2eb76e4f428f425caf9b215323b658839df76c_2_690x170.png)

image796×197 11.6 KB

](https://linux.do/uploads/default/original/4X/6/d/2/6d2eb76e4f428f425caf9b215323b658839df76c.png "image")

[](#p-9124692-vibe-coding-2)Vibe Coding - 优秀文章&项目部分
===================================================

[](#p-9124692-h-3)优秀文章&项目
-------------------------

### [](#p-9124692-ccglm45-4)【实事求是】CC+GLM4.5长期体验和方法分享

[点击访问原帖](https://linux.do/t/topic/1000346)

#### [](#p-9124692-h-5)新项目

对于新项目，目前我用的方法大概是这样的：

1.  项目初始化，先搭架子，所谓架子就是直接搬一个脚手架的项目过来，我不知道各位公司有没有现成的项目模版，如果有的话就直接套用，没有的话可以找网上开源的，几乎每个成熟的框架或者语言都有对应的脚手架，可以生成一个项目的初始模版，你可以按照自己的需求再微调一下，要规划好项目的架构，做好代码的规划，做到心中有数，对将来cc生成代码的帮助很大
    
2.  直接在项目根目录进入claude，如果之前没有设置过中文的可以先输入`# 使用中文回答问题与编辑内容`，就是这么简单粗暴，然后将这句话保存到Claude的全局记忆中，然后执行`/init`命令，让claude生成对项目的初步印象，代码层面先到此为止
    
3.  先进行需求分析和设计，这一步是最重要了，我这个项目是一个平台类前后端的项目，进行完需求分析之后其实就是要进行数据库和接口设计了，这一步是实打实的自己要动脑子，但是依靠大模型也可以减少非常多的工作量，举个简单的例子：
    
    1.  假如一共3张表，可以现在记事本上或者任何地方，用中文写上表名，然后写一下都有哪些字段，哪个是主键，字段大概啥类型，有的可以写，特别容易推测的可以不写，总之可以写的很简单，例如：`用户表：id,用户名，用户密码，邮箱，手机号...`如果需要做一些特殊说明的你就多写一些字，不需要的就可以很简略，整体大概都是这样
        
    2.  然后复制你这段文字以及你要求的markdown文档的格式，粘贴给ai，让他根据自己的理解和要求输出markdown格式的文档，文档的格式举例（仅供参考，根据实际的情况调整）：
        
    3.  ```
        
        
         ``# xx项目数据库表设计
         ## 数据表概览
         | 数据表       | 名称  | 备注说明   |
         | :---------- | :--- | :-------- |
         ## 表结构详情
         ### `user` (用户表)
         | 编号 | 名称   | 数据类型 | 长度 | 小数位 | 允许空值 | 主键 | 默认值 | 说明 | 
         | :--- | :---- | :----- | :--- | :--- | :------ | :--- | :---- | :-- |`` 
        ```
        
    4.  经过我测试，其实可以更加口语化，不需要用这种方式发给LLM，也可以直接说:`生成markdown格式文件，标题是“xx项目数据库设计”，分为两部分，前面为数据表概览，为表格，分3列：数据表，名称，说明；后面为表结构详情，用表格详细展示每个表的结构，列为：编号，名称.....`，真的就像跟人在聊天一样，很随意
        
    5.  其实这一步，可以选择任何的ai，可以在网页或者cherry studio上进行也行，但是用cc的好处就是生成文档后本地修改，方便一些，发给ai之后，ai会根据提供的草稿自动生成英文的表名，字段，字段类型，长度，说明等等
        
    6.  最后这一步就是review，不要指望着一遍能过，要仔细的看每张表的表名、字段名称、字段类型等都是容易出错的地方，毕竟ai只是凭着自己的“经验”在生成，从我个人使用的体验来说，大部分的设计都是可以的，有一些需要手动或者在cc中让ai帮你调，一般命令为`@docs/db.md 修改xx表的xx字段...`，如果是简单的我就手动调了，如果改动比较大的，我会让ai调
        
    7.  所以总结一下，就是人脑设计出雏形，形成草稿，ai根据草稿生成格式化文档，然后人脑review+修改，最终形成最后的版本
        
4.  然后就是接口的设计，由于GLM4.5目前不支持视觉，我说下我的方法
    
    1.  还是一样的套路，根据交互原型，设计出一系列的接口草稿，草稿的形式随意些，例如：
        
    2.  ```
        
        
         `### 1.市场情况统计
         输入：
         无
         返回：
         1. xx公司数量
         2. xx套餐总数
         3. 年销售量
         4. xx用户数量` 
        ```
        
    3.  接口的草稿要和交互页面对应起来，然后把接口草稿和原型设计页面的截图以及以下prompt一起发给多模态的ai，比如Gemini2.5 Pro
        
    4.  ```
        
        
         ``我给你发的截图是一个xx系统的原型设计，我分解为了以下几个后端的api接口，请查看一下截图，判断我设计的接口是否有问题，然后根据我写的接口按照后面的要求输出一个markdown的文档
         ### 1.市场情况统计
         输入：
         无
         返回：
         1. xx公司数量
         2. xx套餐总数
         3. 年销售量
         4. xx用户数量
           
         ....(此处写其他接口)
           
         API文件格式要求：
         1. markdown格式
         2. 开头包含以下内容
         ## 概述
         [此处写项目简介] 
         ## 基础信息
           
         - **Base URL**: `/v1`
         - **认证方式**: JWT Token
         - **响应格式**: JSON
           
         ## 通用响应格式
           
         ‍```json
         {
           "code": 0,
           "message": "success",
           "data": {}
         }
         ‍```
         3. 接口列表，包含以下内容
         3.1 接口名称，使用中文
         3.2 接口地址，例如`GET /v1/functionxxx`
         3.3 请求参数（或路径参数），使用markdown表格表示，表格有4列，包含参数名，类型，必填，说明
         3.4 响应示例
         3.5 响应字段说明，使用markdown表格表示，字段名、类型、说明`` 
        ```
        
    5.  markdown格式按照自己的需求修改，我其实写的已经比较口语化了，随便改改很easy的，这一步可能要进行多次，因为系统的界面肯定是多个，在review的时候，有一个需要注意的点就是，因为模型不同或者缺少上下文的原因，接口设计中的某些参数可能和数据库表中的参数有不一致的情况，这是一个很细节的问题，但是会影响后面的开发流程，所以一定要保持一致，可以直接全局替换，或者让cc自己核对自己修改，其实全局替换更方便一些
        
    6.  这一步很关键，涉及到最终生成代码的情况，就是在每个接口的下面，加上几行字，写一下实现逻辑，这个可以很简单，根据接口情况而定，最好写一下涉及到的表，可以用中文名就行，例如：
        
    7.  ```
        
        
         `(接口内容...)
         实现逻辑：
         1. 根据用户id，判断用户表中是否已经存在，不存在则返回该用户不存在
         2. 如果存在且密码不为空，则返回用户已注册
         3. 如果存在且密码为空，则注册成功
         4. 注意，该注册和一般的注册不同，该注册时表中已经存在用户数据，操作相当于是绑定密码，所以是update，而非insert
           
         (接口内容...)
         实现逻辑：
         1. 查询用户表返回相应信息` 
        ```
        
5.  虽然到目前为止，一行代码也没写，行军打仗，兵马未动，粮草先行，良好的文档就是项目的粮草，有了准确的文档以及好的架构设计，对于后面生成的代码的成功率有非常大的提升，同时可以从很大程序上避免将来生成屎山代码
    
6.  现在可以开始尝试让AI去生成代码了，先生成数据库相关的代码，根据数据库设计文档，非常容易实现，生成好了之后一定要花时间去核对
    
7.  生成一些全局性的业务代码，例如全局变量，Contants等，弄完这些了记得更新一下CLAUDE.md，可以再`/init`一下
    
8.  然后生成业务接口代码，因为现在已经有完整的接口文档和业务逻辑了，可以直接`@api.md`然后再告诉AI生成哪个接口的代码，此时最好就是一次只生成1个接口的，然后review，需要注意的是，及时调整，当生成一部分代码后，可能就需要小重构一次，重构是为了避免将来的屎山，重构的工作也可以让AI辅助完成，例如告诉他合并哪些代码，拆分哪些代码，把哪些代码移植到哪个文件中，注意如果这时候你拿不定主意，也可以问AI，把你的想法写出来，然后让AI结合现在的代码分析一下哪种重构方案比较好，或者暂时不重构，总之，好好利用它
    
9.  接下来就是不断的去重复这个过程，生成代码->Review->阶段性调整->生成代码…
    
10.  修改代码时，有时候会出现没修改全的现象，此时加上修改的范围即可，举个例子，当我们修改某个结构体的时候，其实涉及到这个结构体的所有的接口都要改一下，所以prompt需要告诉ai说`把涉及到的接口都修改一下`，ai就会联系上下文全局修改了。
    
11.  需要修改什么时，最好直接粘贴具体的函数名称，比如RegisterUser，否则LLM会根据你的描述去猜测接口的名字，然后不断的去调用工具和猜测，比较浪费时间和token
    
12.  如果需求更新了，要么先更新文档，让AI跟着改，要么先改代码，再反过来更新文档，总之最好做到文档和代码的对齐，这里推荐业务逻辑变更的话就先更新文档，如果表结构变更了可以先更新代码，总之，怎么方便怎么来，也可以让AI一点一点核对代码和文档不一致的地方，然后列出来
    
13.  尽量小范围的生成代码，而且一定要review，并及时做动态的调整，尽早的调整结构能避免将来堆起来的屎山
    
14.  记得及时更新AI的记忆，即CLAUDE.md
    
15.  我举得的例子是一个比较简单的例子，大家能理解其中的思想就可以了，复杂的事情也是一点点简单的事情堆砌起来的，一点一点来吧
    

#### [](#p-9124692-h-6)老项目

老项目是指不是从头开始的项目，可能已经有成千上万行代码了，有着复杂的项目结构和历史遗留问题，我分享一下我的一些经历吧，我接受了一个N年前的老项目，需要在那个项目上裁剪掉一些功能，然后再增加一些功能

项目的基本情况：后端golang，基于go1.11的特制版，项目带了一个巨大的vendor包，去除掉vendor包以及裁剪掉的代码，整体代码量在12w+行，前端Vue2，node 12.15

项目的功能涉及的比较多，多租户的平台类项目，对接k8s，docker，虚拟资源管理，对接各种中间件、应用等，总之是个类似云平台的大杂烩，难点在于年代太久了，很多依赖全都过时了，现在go已经更新到1.25了，node 22，光编译和部署就需要一堆的配置文件和脚本，跑起来都是问题，更别提裁剪和开发新功能，而且用的go是改造过的，编译项目需要到docker里面，可以说一开始跑起来都费劲，所有和项目相关的产品、开发、测试等都走了，然后就是一堆过时的文档，可以说真是让人头大，还好之前我大概了解过这个产品，前期先花了一些时间熟悉了项目代码然后完成了裁剪操作，幸好之前的代码比较模块化，裁剪起来才没那么费劲

我觉得这种活已经是开发最不愿接手的活了，不论是开发还是调试都非常的复杂，过程繁琐，但没办法，拿人钱财，替人消灾，该接就得接。

老项目的方式和新项目有一些区别，需要注意的就是以下几点：

1.  首先还是自动添加项目记忆文件`/init`，另外其实可以在子目录中也添加记忆文件，就是在子目录增加CLAUDE.md，这个也可以让AI去生成，后面在写代码或者讨论方案的过程中，CC如果发现了子目录有CLAUDE.md也会优先去读的
2.  在实现功能的时候，可以切换到默认模式，跟AI讨论，例如需要增加一个新功能，怎样在不影响大部分代码的情况下完成这个功能，可以让AI把结果整理输出到一个文件中，这一步是需要多次迭代的，而且你自己心里要有个大概的设计方案，在和AI讨论的时候可以附加上这个方案，让AI完善，不要指望着一遍能过，反复讨论，反复优化细节，反复修改
3.  AI实现代码的时候可能会用到项目中其他的模块，而由于项目比较大或者太复杂，我建议手动提醒，即直接了当的给AI示例，@出文件和函数名称，让AI参考调用方式，并自行组织数据结构，这样可以少出错，提高成功率
4.  修改bug时，不一定就是直接把错误日志贴给ai，让ai直接修复，我这边出了一个非常无语的bug，就是底层sdk的一个方法中的参数标错了，类似于Login(UserId, Password)，看起来应该是传UserId，但是其实正确的应该是传UserCode，这个问题导致了一些很奇葩的错误，由于这个是封装SDK时的bug，其他地方在用时讲错就错的写的是UserId(但变量值是UserCode)，导致我找了半天没找到问题在哪，而且调试起来效率非常低，我就把错误日志发给ai，让ai全盘考虑，深度思考，讨论过程中能看到他在一点点的翻代码，而且都翻到底层vendor中的sdk的详细实现了，经过几轮的讨论后，他居然真的找出了错误的原因，起初我还不信，最后跟着他的代码路线一路走下来后发现居然是真的，这是目前为止，ai编程最震惊我的一点了，因为要找到这个bug真的不容易，首先cc没有运行环境，这个项目跑起来需要到虚拟机中的docker中，所以cc没法运行代码，其次这里面有多层的抽象封装，接口套接口，一层又一层，跳起来看得一点点找具体实现，并且最后这个代码是在底层vendor的依赖中，需要深入到底层把SDK代码大概都看一遍才知道这个错误，真的是厉害，如果不是ai，我肯定要搞到半夜才能发现这个问题！
5.  再说一点前端的情况吧，真的很easy，在后端接口已经完成了的情况下，可以先进行api的编写，另外如果你已经有了一些UI层的风格以及组件，可以让cc直接参考某个页面或者组件实现xx功能，只要你把功能列清楚，然后来回交互几次，基本就弄好了，即使没有视觉，可以通过语言描述告诉他页面有什么问题，让他再调整一下细节就OK了
6.  其他的就没啥可说了，项目不但搞定了，而且还提前了很多天。其实要点就是要有耐心，一些问题不要开了编辑模式以后就直接撸，有时候开plan也不行，在思路比较模糊的时候，可以和ai一起讨论实现方法，然后写到设计文档里，通过多次的讨论优化设计方案，当方案确实没问题了，再一点点实现也不迟，当然总设计师还是你，你一定要有一个宏观层面的架构设计，让ai去填充细节

这就是两个月以来我使用CC+GLM4.5完成的两个项目，其实还有一些其他的杂活，不过这两个项目我觉得比较有代表性吧，所以就写出来分享给大家了，虽然也有一定的局限性，但是我想在各个编程领域的整体思路应该都是一样的，总结一下吧：

#### [](#p-9124692-h-7)总结一下

1.  首先理解好ai的角色，他能帮你提高效率，帮你干脏活累活，听你指挥，你是统帅，他是将领，可以让他给建议，但是**你要带着他走，而不是被他牵着走**
2.  文档要齐全，这点很重要，ai记忆力很差，并且是个近视眼，你必须要有个全局的map，他才不至于迷路
3.  及时review，而且一定要review，需要重构的时候果断停下新功能，优先重构代码结构
4.  做一个新功能就commit一次，不想搞那么多commit记录，可以`git commit --amend`，不push就行，这样的话方便整体回退
5.  稍微复杂点的功能可以先讨论用默认模式几轮，默认模式就是不带plan和edit的模式，你直接问问题，他会结合项目回答，但不会盲目的执行
6.  提示词什么的其实也是需要慢慢摸索和磨合的，永久了其实就知道该怎么问，ai的能力边界在哪就清楚了
7.  另外，我没有使用任何mcp和subagent，所以测试也算是cc+glm的下限了

### [](#p-9124692-wsl-codex-8)**教程：让 WSL 成功使用 Codex**

[点击访问原帖](https://linux.do/t/topic/1002178)

在 WSL（Windows Subsystem for Linux）环境下使用 Codex 时，常见的两个问题是：

1.  WSL 网络请求无法直连外网 → 需要通过代理（如 v2ray）。
2.  WSL 不能唤起浏览器完成 Codex 登录认证 → 需要借助 Windows 完成登录，再将认证文件复制到 WSL。

下面是完整的解决步骤：

#### [](#p-9124692-h-1-wsl-9)**1\. 在 WSL 中设置网络代理**

Codex 的请求需要能访问外网。如果你在 Windows 上运行了 v2ray（假设监听端口为 10809），则需要在 WSL 中让请求走这个代理。

##### [](#p-9124692-h-1-windows-10)**（1）确认 Windows 主机地址**

在 WSL 中运行：

```


`cat /etc/resolv.conf` 
```

通常能看到类似：

```


`nameserver 172.28.192.1` 
```

这里的 `172.28.192.1` 就是 Windows 宿主机在 WSL 网络中的地址。 （每次重启 WSL 可能会变，需重新查看。）

##### [](#p-9124692-h-2-11)**（2）设置代理环境变量**

在 WSL 的`~/.bashrc` 或`~/.zshrc`中加入：

```


`export http_proxy="http://172.28.192.1:10809"
export https_proxy="http://172.28.192.1:10809"
export all_proxy="socks5://172.28.192.1:10808"` 
```

然后刷新配置：

```


`source ~/.bashrc
注：10809 是 http 代理端口，10808 是 socks 代理端口，需与 Windows v2ray 的实际端口保持一致。` 
```

##### [](#p-9124692-h-3-12)**（3）测试代理是否生效**

```


`curl -I https://www.google.com` 
```

#### [](#p-9124692-h-2-codex-13)**2\. 完成 Codex 登录认证**

Codex CLI 在首次运行时会尝试唤起浏览器进行 OAuth 登录。但 WSL 无法直接打开 Windows 浏览器，所以需要在 Windows 端完成登录。

##### [](#p-9124692-h-1-windows-codex-14)**（1）在 Windows 中完成 Codex 登录**

在 Windows Terminal/PowerShell/CMD 中运行 `codex` ，然后选择通过登录的方式使用。

登录成功后，会在 Windows 用户目录下生成认证文件：

```


`C:\Users\<你的用户名>\.codex\auth.json` 
```

##### [](#p-9124692-h-2-wsl-15)**（2）复制认证文件到 WSL**

进入 Windows 的 .codex 目录，找到 auth.json，然后复制到 WSL。

```


`cp /mnt/c/Users/<你的用户名>/.codex/auth.json ~/.codex/` 
```

##### [](#p-9124692-h-3-codex-16)**(3) 使用`codex`**

此时应该就可以使用codex了 如果有问题，主要可能是这两方面：

1.  网络问题，是否真的走了代理
2.  登录验证的文件是否有效，一段时间后可能会过期，再重复登录操作一次即可

### [](#p-9124692-superclaude-claude-codemcpai-17)SuperClaude × Claude Code：MCP驱动的AI编程爆改指南

[点击访问原帖](https://www.aivi.fyi/aiagents/introduce-SuperClaude)

#### [](#p-9124692-h-18)主要作用

##### [](#p-9124692-h-1-19)1\. 认知专业化

architect：系统设计和可扩展性  
frontend：用户体验和React开发  
backend：API开发和性能优化  
security：威胁建模和安全代码  
analyzer：根因分析和调试  
mentor：教学和指导  
refactorer：代码质量和简化  
performance：性能优化  
qa：质量保证和测试

##### [](#p-9124692-h-2-20)2\. 工作流程标准化

提供了18个专业化的斜杠命令，涵盖开发的各个方面：发命令：/user:build、/user:dev-setup、/user:test  
分析命令：/user:analyze、/user:troubleshoot、/user:improve维命令：/user:deploy、/user:migrate、/user:scan计命令：/user:design

##### [](#p-9124692-h-3-21)3\. 智能文档查找

通过Context7自动查找和引用官方文档，确保代码实现基于最新的最佳实践。

#### [](#p-9124692-h-22)安装和使用方式

##### [](#p-9124692-h-23)安装步骤

```


`1. 克隆项目
git clone https://github.com/NomenAK/SuperClaude.git
cd SuperClaude

# 2. 执行安装脚本
./install.sh

# 3. 验证安装
ls -la ~/.claude/  # 应该显示4个主要文件
ls -la ~/.claude/commands/  # 应该显示17个文件` 
```

#### [](#p-9124692-h-24)![](https://linux.do/images/emoji/twemoji/clipboard.png?v=14)
 命令格式规范

##### [](#p-9124692-h-25)基本格式

```


`/命令名 --标志1 --标志2 --persona-角色名 "任务描述"` 
```

##### [](#p-9124692-h-26)重要说明

![](https://linux.do/images/emoji/twemoji/white_check_mark.png?v=14)
 使用直接斜杠格式：/build, /analyze, /review  
![](https://linux.do/images/emoji/twemoji/white_check_mark.png?v=14)
 标志使用双破折号：–flag  
![](https://linux.do/images/emoji/twemoji/white_check_mark.png?v=14)
 Persona作为通用标志使用：–persona-名称

#### [](#p-9124692-h-27)![](https://linux.do/images/emoji/twemoji/building_construction.png?v=14)
 开发构建类命令

##### [](#p-9124692-h-1-react-28)1\. React项目开发

```


`/build --react --magic --tdd --persona-frontend` 
```

用途： 使用React框架开发项目，集成Magic UI构建器和测试驱动开发

##### [](#p-9124692-h-2-api-29)2\. API后端开发

```


`/build --api --tdd --coverage --persona-backend` 
```

用途： 构建后端API，采用测试驱动开发和代码覆盖率检查

##### [](#p-9124692-h-3-30)3\. 项目初始化

```


`/build --init --magic --c7 --plan --persona-frontend` 
```

用途： 初始化新项目，启用Magic UI构建器和Context7文档查找

##### [](#p-9124692-h-4-31)4\. 功能开发

```


`/build --feature --tdd --persona-frontend` 
```

用途： 开发特定功能，采用测试驱动开发方法

#### [](#p-9124692-mcp-server-32)![](https://linux.do/images/emoji/twemoji/rocket.png?v=14)
必要的MCP Server添加命令

```


`添加context7
claude mcp add --transport http context7 https://mcp.context7.com/mcp

# 添加sequential-thinking
claude mcp add sequential-thinking npx @modelcontextprotocol/server-sequential-thinking

# 添加puppeteer
npx @modelcontextprotocol/server-puppeteer

claude mcp add puppeteer npx @modelcontextprotocol/server-puppeteer

# 添加magic (https://21st.dev/magic/onboarding?step=create-component)
claude mcp add magic npx @21st-dev/magic@latest --env API_KEY=你的api key` 
```

#### [](#p-9124692-h-33)![](https://linux.do/images/emoji/twemoji/rocket.png?v=14)
测试用例

```


`# 分析开源项目
/analyze --architecture --persona-architect  --seq

# 组合命令
/build --react --magic "简单的todo list 应用"build --init --c7 --plan --persona-frontend "创建一个模拟太阳系的HTML动画，包含8大行星的轨道运动"

/build --react --magic "todo应用原型"

# 分析架构
/analyze --architecture --persona-architect

# 调用MCP分析架构
/analyze --architecture --seq

# 规划整体技术架构
/design --api --ddd "用户管理系统" --persona-architect

# 生成产品需求文档
/design --api --prd "进销存管理系统"

# 生成产品需求文档
/design --prd "移动端社交应用" --persona-frontend

# 定义REST或GraphQL API规范
/design --api --openapi "电商订单API" --persona-backend

# 教育平台设计
/design --api --openapi "在线学习管理系统" --persona-backend` 
```

#### [](#p-9124692-persona-34)![](https://linux.do/images/emoji/twemoji/bullseye.png?v=14)
 Persona角色系统

##### [](#p-9124692-h-35)可用角色

–persona-architect - 系统架构师，专注设计和可扩展性  
–persona-frontend - 前端专家，专注UX和React开发  
–persona-backend - 后端专家，专注API和性能  
–persona-security - 安全专家，专注威胁建模和安全代码  
–persona-qa - 质量保证专家，专注测试和质量  
–persona-performance - 性能专家，专注优化和瓶颈分析  
–persona-analyzer - 分析专家，专注根因分析和调试  
–persona-mentor - 导师专家，专注教学和指导  
–persona-refactorer - 重构专家，专注代码质量和简化

#### [](#p-9124692-h-36)![](https://linux.do/images/emoji/twemoji/triangular_flag.png?v=14)
 通用标志说明

##### [](#p-9124692-h-37)规划与思考

–plan - 显示执行计划（在执行前预览）  
–think - 标准分析模式  
–think-hard - 深度分析模式  
–ultrathink - 关键分析模式

##### [](#p-9124692-mcp-38)MCP服务器控制

–c7 - 启用Context7文档查找  
–seq - 启用Sequential深度思维  
–magic - 启用Magic UI构建器  
–pup - 启用Puppeteer浏览器测试

##### [](#p-9124692-h-39)输出控制

–uc - UltraCompressed模式（约70%令牌减少）  
–verbose - 详细输出模式

##### [](#p-9124692-h-40)特定功能标志

–init - 项目初始化  
–feature - 功能开发  
–tdd - 测试驱动开发  
–coverage - 代码覆盖率  
–e2e - 端到端测试  
–dry-run - 预演模式  
–rollback - 回滚准备

#### [](#p-9124692-h-41)![](https://linux.do/images/emoji/twemoji/chart_increasing.png?v=14)
 复杂工作流示例

##### [](#p-9124692-h-42)完整开发流程

```


`1. 项目规划
/design --api --ddd --plan --persona-architect

# 2. 前端开发
/build --react --magic --tdd --persona-frontend

# 3. 后端开发
/build --api --tdd --coverage --persona-backend

# 4. 质量检查
/review --quality --evidence --persona-qa

# 5. 安全扫描
/scan --security --owasp --persona-security

# 6. 性能优化
/improve --performance --iterate --persona-performance

# 7. 部署准备
/deploy --env staging --plan --persona-architect` 
```

##### [](#p-9124692-h-43)问题排查流程

```


`# 1. 问题分析
/troubleshoot --investigate --prod --persona-analyzer

# 2. 根因分析
/troubleshoot --prod --five-whys --seq --persona-analyzer

# 3. 性能分析
/analyze --profile --perf --seq --persona-performance

# 4. 修复实施
/improve --quality --threshold 95% --persona-refactorer` 
```

### [](#p-9124692-claude-code-zen-mcpai-44)Claude Code × Zen MCP：多AI协作编程革命

[点击访问原帖](https://www.aivi.fyi/aiagents/introduce-Claude-Code+Zen-MCP),[点击访问GitHub](https://github.com/BeehiveInnovations/zen-mcp-server)

#### [](#p-9124692-h-45)专业开发工具

##### [](#p-9124692-chat-46)chat - 协作思维伙伴

头脑风暴、获取第二意见  
验证方法和实施计划  
技术比较和最佳实践讨论

##### [](#p-9124692-thinkdeep-47)thinkdeep - 扩展推理分析

使用Gemini的专业思维模型增强推理能力  
提供Claude分析的第二意见  
挑战假设，识别边缘情况

**#####** codereview - 专业代码审查

按严重程度优先排序问题（![](https://linux.do/images/emoji/twemoji/red_circle.png?v=14)
 严重 → ![](https://linux.do/images/emoji/twemoji/green_circle.png?v=14)
 轻微）  
支持专门审查：安全、性能、快速检查  
可强制执行编码标准

**#####** precommit - Git变更验证

递归发现多个git仓库  
根据需求验证变更  
检测未完成的变更和安全漏洞

**#####** debug - 根因分析

生成多个排序假设进行系统调试  
接受错误上下文、堆栈跟踪和日志  
提供结构化根因分析

**#####** analyze - 通用代码理解

分析单个文件或整个目录  
支持专门分析：架构、性能、安全、质量  
识别模式、反模式和重构机会

**#####** get\_version - 服务器信息

获取版本和配置详情

#### [](#p-9124692-h-48)安装和使用方式

##### [](#p-9124692-h-5-49)5分钟快速开始

###### [](#p-9124692-h-1-50)1\. 克隆仓库

```


`git clone https://github.com/BeehiveInnovations/zen-mcp-server.git
cd zen-mcp-server` 
```

###### [](#p-9124692-h-2-51)2\. 一键设置

```


`./setup-docker.sh` 
```

这个脚本会：

构建包含所有依赖的Docker镜像  
创建.env文件（自动使用环境变量中的API密钥）  
启动Redis服务支持AI对话记忆  
启动MCP服务器示Claude Desktop配置信息

###### [](#p-9124692-h-3-api-52)3\. 配置API密钥

```


`编辑.env文件添加API密钥
nano .env

# 文件内容： GEMINI_API_KEY=your-gemini-api-key-here
# OPENAI_API_KEY=your-openai-api-key-here
# WORKSPACE_ROOT=/Users/your-username` 
```

##### [](#p-9124692-claude-code-53)集成到Claude Code

```


`# 直接通过Claude Code CLI添加MCP服务器
claude mcp add zen -s user -- docker exec -i zen-mcp-server python server.py

# 验证服务器列表
claude mcp list

# 启动claude code连接到新添加的mcp服务器
claude` 
```

##### [](#p-9124692-h-54)工具选择指南

需要思维伙伴？ → chat（头脑风暴、获取第二意见）  
需要深度思考？ → thinkdeep（扩展分析、发现边缘情况）码需要审查？ → codereview（错误、安全、性能问题）  
预提交验证？ → precommit（提交前验证git变更）  
有问题需要调试？ → debug（根因分析、错误追踪）理解代码？ → analyze（架构、模式、依赖关系）

#### [](#p-9124692-h-55)核心工具说明

chat: 协作思考和开发对话  
thinkdeep: 扩展推理和问题解决  
codereview: 专业代码审查，有严重性分级  
precommit: 提交前的 git 变更验证  
debug: 根本原因分析和调试  
analyze: 通用文件和代码分析

### [](#p-9124692-h-56)一次跑通！省钱又可靠的顾问式编码！

[点击访问原帖](https://linux.do/t/topic/856803)

```


`## 角色定位
你是一个专业的技术架构师和需求分析专家，负责深度理解用户需求并提供全面的解决方案设计。你的核心任务是**理解、分析、设计**，而非直接实现。

## 工作流程

### 第一步：需求理解与确认
当用户提出需求时，你需要：
1. **重述理解**：用自己的语言清晰地重新描述用户的需求
2. **核心目标**：明确指出用户想要达成的核心目标
3. **关键约束**：识别任何明示或暗示的约束条件
4. **潜在需求**：指出可能被忽略但重要的隐含需求
5. **确认询问**：如有歧义，提出澄清性问题

### 第二步：方案设计与对比
在确认理解无误后，提供：

#### 2.1 解决方案概览
- 列出所有可行的技术方案（通常2-4个）
- 每个方案用一句话概括核心思路

#### 2.2 详细方案分析
对每个方案提供：
- **方案名称**：简洁明了的命名
- **核心思路**：3-5句话说明实现原理
- **实施步骤**：分解为5-8个主要步骤
- **技术栈建议**：推荐的工具/框架/库
- **优势**：
  - 性能特点
  - 可维护性
  - 扩展性
  - 其他优势
- **劣势**：
  - 技术难点
  - 潜在风险
  - 限制条件
- **适用场景**：最适合什么情况
- **注意事项**：实施时需特别关注的点
- **时间复杂度估算**：开发工作量预估

### 第三步：方案推荐
- **推荐方案**：基于通用场景的最优选择
- **推荐理由**：为什么这是最平衡的选择
- **决策矩阵**：提供一个简单的对比表格

### 第四步：等待决策
结束时明确告知用户：
- "请选择您倾向的方案，我将为您生成详细的实施指南"
- "如需调整需求或了解更多细节，请随时告知"

## 输出规范

### 格式要求
- 使用清晰的标题层级（#, ##, ###）
- 重要信息用**粗体**标注
- 列表形式展示步骤和要点
- 用表格对比不同方案（当方案≥3个时）

### 语言风格
- 专业但不晦涩
- 逻辑清晰，层次分明
- 避免冗长，保持简洁
- 技术术语需简要解释

## 重要原则

1. **不要直接给出代码**：这个阶段只做方案设计
2. **不要偏向单一方案**：客观展示所有选项
3. **不要忽略非技术因素**：考虑团队能力、时间、成本等
4. **不要过度设计**：方案要切实可行
5. **始终以用户需求为中心**：不要偏离原始目标

## 示例回复模板

```
## 需求理解

我理解您想要 [重述需求]。核心目标是 [目标]，主要约束包括 [约束]。

[如有疑问：在继续之前，我想确认一下：...]

## 解决方案

### 方案一：[方案名]
**核心思路**：...
**优势**：...
**劣势**：...
[其他要素]

### 方案二：[方案名]
[同上结构]

## 方案对比与建议

[对比表格或说明]

**推荐方案**：方案X
**理由**：...

请选择您倾向的方案，我将协助您规划详细的实施步骤。
```

---

记住：你的价值在于**深度理解**和**全面分析**，而不是急于实现。让用户做出明智的技术决策是你的核心使命。` 
```

### [](#p-9124692-claude-code-sub-agents-57)Claude Code Sub-Agents：从手工作坊到自动化工厂

[点击访问原帖](https://linux.do/t/topic/816163)

#### [](#p-9124692-sub-agents-58)Sub-Agents解决方案：四个专家的自动化团队

Claude Code的Sub-Agents功能让我们可以组建一个专业AI团队，每个专家在独立上下文中工作，通过智能链式调用协作完成整个开发流程。

#### [](#p-9124692-h-59)核心工作流：质量门控的自动化流水线

```


`spec-generation → spec-executor → spec-validation → (≥95%?) → spec-testing
      ↑                                               ↓ (<95%)
      ←←←←←← 自动优化循环，直到质量达标 ←←←←←←` 
```

**四个核心角色：** 

1.  **spec-generation agent** - 规格生成专家
    
    *   自动生成requirements.md, design.md, tasks.md
    *   EARS格式需求，完整架构设计，可执行任务清单
2.  **spec-executor agent** - 代码实现专家
    
    *   基于规格文档实现完整功能
    *   自动化任务管理，实时进度跟踪
3.  **spec-validation agent** - 质量验收专家
    
    *   多维度评分：需求符合度(30%) + 代码质量(25%) + 安全性(20%) + 性能(15%) + 测试覆盖(10%)
    *   95%质量门控，不达标自动循环优化
4.  **spec-testing agent** - 测试生成专家
    
    *   全面测试策略：单元测试 + 集成测试 + 安全测试
    *   自动化测试执行和CI/CD集成

##### [](#p-9124692-h-60)总工作流

`~/.claude/commands/spec-workflow.md`

```


``## Usage
`/spec-workflow <FEATURE_DESCRIPTION>`

## Context
- Feature to develop: $ARGUMENTS
- Automated multi-agent workflow with quality gates
- Sub-agents work in independent contexts with smart chaining

## Your Role
You are the Workflow Orchestrator managing an automated development pipeline using Claude Code Sub-Agents. You coordinate a quality-gated workflow that ensures 95%+ code quality through intelligent looping.

## Sub-Agent Chain Process

Execute the following chain using Claude Code's sub-agent syntax:


First use the spec-generation sub agent to generate complete specifications for [$ARGUMENTS], then use the spec-executor sub agent to implement the code based on specifications, then use the spec-validation sub agent to evaluate code quality with scoring, then if score ≥95% use the spec-testing sub agent to generate comprehensive test suite, otherwise first use the spec-generation sub agent again to improve specifications based on validation feedback and repeat the chain.


## Workflow Logic

### Quality Gate Mechanism
- **Validation Score ≥95%**: Proceed to spec-testing sub agent
- **Validation Score <95%**: Loop back to spec-generation sub agent with feedback
- **Maximum 3 iterations**: Prevent infinite loops

### Chain Execution Steps
1. **spec-generation sub agent**: Generate requirements.md, design.md, tasks.md
2. **spec-executor sub agent**: Implement code based on specifications  
3. **spec-validation sub agent**: Multi-dimensional quality scoring (0-100%)
4. **Quality Gate Decision**: 
   - If ≥95%: Continue to spec-testing sub agent
   - If <95%: Return to spec-generation sub agent with specific feedback
5. **spec-testing sub agent**: Generate comprehensive test suite (final step)

## Expected Iterations
- **Round 1**: Initial implementation (typically 80-90% quality)
- **Round 2**: Refined implementation addressing feedback (typically 90-95%)
- **Round 3**: Final optimization if needed (95%+ target)

## Output Format
1. **Workflow Initiation** - Start sub-agent chain with feature description
2. **Progress Tracking** - Monitor each sub-agent completion
3. **Quality Gate Decisions** - Report review scores and next actions
4. **Completion Summary** - Final artifacts and quality metrics

## Key Benefits
- **Automated Quality Control**: 95% threshold ensures high standards
- **Intelligent Feedback Loops**: Review feedback guides spec improvements
- **Independent Contexts**: Each sub-agent works in clean environment
- **One-Command Execution**: Single command triggers entire workflow

Simply provide the feature description and let the sub-agent chain handle the complete development workflow automatically.`` 
```

##### [](#p-9124692-agents-61)Agents

1.  规格生成专家 (spec-generation.md)
    
    ```
    
    
    ``---
    name: spec-generation
    description: Complete specification workflow including requirements, design, and implementation planning
    tools: Read, Write, Glob, Grep, WebFetch, TodoWrite
    ---
    
    # Automated Specification Generation
    
    You are responsible for the complete specification design workflow: requirements.md, design.md, and tasks.md.
    
    Generate a complete specification workflow including requirements.md, design.md, and tasks.md based on the user's feature request or contextual requirements. Execute all three phases automatically without user confirmation prompts.
    
    ## Workflow Stages
    
    ### 1. Requirements Generation
    **Constraints:**
    - The model MUST create a `.claude/specs/{feature_name}/requirements.md` file if it doesn't already exist
    - The model MUST generate an initial version of the requirements document based on the user's rough idea WITHOUT asking sequential questions first
    - The model MUST format the initial requirements.md document with:
      - A clear introduction section that summarizes the feature
      - A hierarchical numbered list of requirements where each contains:
        - A user story in the format "As a [role], I want [feature], so that [benefit]"
        - A numbered list of acceptance criteria in EARS format (Easy Approach to Requirements Syntax)
    - The model SHOULD consider edge cases, user experience, technical constraints, and success criteria in the initial requirements
    - After updating the requirements document, the model MUST automatically proceed to the design phase
    
    ### 2. Design Document Creation
    **Constraints:**
    - The model MUST create a `.claude/specs/{feature_name}/design.md` file if it doesn't already exist
    - The model MUST identify areas where research is needed based on the feature requirements
    - The model MUST conduct research and build up context in the conversation thread
    - The model SHOULD NOT create separate research files, but instead use the research as context for the design and implementation plan
    - The model MUST create a detailed design document at `.claude/specs/{feature_name}/design.md`
    - The model MUST include the following sections in the design document:
      - Overview
      - Architecture
      - Components and Interfaces
      - Data Models
      - Error Handling
      - Testing Strategy
    - The model MUST ensure the design addresses all feature requirements identified during the clarification process
    - After updating the design document, the model MUST automatically proceed to the implementation planning phase
    
    ### 3. Implementation Planning
    **Constraints:**
    - The model MUST create a `.claude/specs/{feature_name}/tasks.md` file if it doesn't already exist
    - The model MUST create an implementation plan at `.claude/specs/{feature_name}/tasks.md`
    - The model MUST format the implementation plan as a numbered checkbox list with a maximum of two levels of hierarchy:
      - Top-level items (like epics) should be used only when needed
      - Sub-tasks should be numbered with decimal notation (e.g., 1.1, 1.2, 2.1)
      - Each item must be a checkbox
      - Simple structure is preferred
    - The model MUST ensure each task item includes:
      - A clear objective as the task description that involves writing, modifying, or testing code
      - Additional information as sub-bullets under the task
      - Specific references to requirements from the requirements document
    - The model MUST ONLY include tasks that can be performed by a coding agent (writing code, creating tests, etc.)
    - The model MUST NOT include tasks related to user testing, deployment, performance metrics gathering, or other non-coding activities
    - The model MUST focus on code implementation tasks that can be executed within the development environment
    
    ## Key Constraints
    - Execute all three phases automatically without user confirmation
    - Every task must be executable by a coding agent
    - Ensure requirements completely cover all needs
    - The model MUST automatically generate all three documents (requirements.md, design.md, tasks.md) in sequence
    - The model MUST complete the entire workflow without requiring user confirmation between phases
    - Perform "ultrathink" reflection phase to integrate insights
    
    Upon completion, provide complete specification foundation for spec-executor.`` 
    ```
    
2.  代码实现专家 (spec-executor.md)
    
    ```
    
    
    ``---
    name: spec-executor
    description: Specification execution coordinator with full traceability and progress tracking
    tools: Read, Edit, MultiEdit, Write, Bash, TodoWrite, Grep, Glob
    ---
    
    # Specification Execution Coordinator
    
    You are responsible for executing code implementation based on complete specification documents, ensuring full traceability and progress tracking.
    
    ## Execution Process
    
    ### 1. Artifact Discovery
    - Read `.claude/specs/{feature_name}/requirements.md` to understand user stories and acceptance criteria
    - Read `.claude/specs/{feature_name}/design.md` to understand architecture and implementation approach
    - Read `.claude/specs/{feature_name}/tasks.md` to get detailed implementation checklist
    
    ### 2. Todo Generation
    - Convert each task from tasks.md into actionable todo items
    - Add priority levels based on task dependencies
    - Include references to specific requirements and design sections
    - Break down complex tasks into smaller sub-tasks if needed
    
    ### 3. Progressive Implementation
    - Mark todos as in_progress before starting each task
    - Implement code following design specifications
    - Validate each implementation against requirements
    - Mark todos as completed only when fully validated
    - Run tests and checks as specified in the design
    
    ### 4. Continuous Validation
    - Cross-reference implementation with requirements acceptance criteria
    - Ensure code follows architectural patterns from design document
    - Verify integration points work as designed
    - Maintain code quality and consistency standards
    
    ## Output Format
    1. **Specification Summary** - Overview of requirements, design, and tasks found
    2. **Generated Todos** - Comprehensive todo list with priorities and references
    3. **Progressive Implementation** - Code implementation with real-time progress tracking
    4. **Validation Results** - Verification that implementation meets all specifications
    5. **Completion Report** - Summary of implemented content and remaining items
    
    ## Constraints
    - MUST read all three specification documents before starting
    - MUST create todos for every task in tasks.md
    - MUST mark todos as completed only when fully implemented and validated
    - MUST reference specific requirements when implementing features
    - MUST follow the architectural patterns defined in design.md
    - MUST NOT skip or combine tasks without explicit validation
    - MUST run appropriate tests and quality checks throughout implementation
    
    Perform "ultrathink" reflection phase to form coherent solution.`` 
    ```
    
3.  质量验收专家 (spec-validation.md)
    
    ```
    
    
    `---
    name: spec-validation
    description: Multi-dimensional code validation coordinator with quantitative scoring (0-100%)
    tools: Read, Grep, Write, WebFetch
    ---
    
    # Code Validation Coordinator
    
    You are the Code Validation Coordinator directing four validation specialists and providing quantitative scoring for spec-executor implementation results.
    
    ## Your Role
    You are the Code Validation Coordinator directing four validation specialists:
    1. **Quality Auditor** – examines code quality, readability, and maintainability.
    2. **Security Analyst** – identifies vulnerabilities and security best practices.
    3. **Performance Reviewer** – evaluates efficiency and optimization opportunities.
    4. **Architecture Assessor** – validates design patterns and structural decisions.
    
    ## Process
    1. **Code Examination**: Systematically analyze target code sections and dependencies.
    2. **Multi-dimensional Validation**:
       - Quality Auditor: Assess naming, structure, complexity, and documentation
       - Security Analyst: Scan for injection risks, auth issues, and data exposure
       - Performance Reviewer: Identify bottlenecks, memory leaks, and optimization points
       - Architecture Assessor: Evaluate SOLID principles, patterns, and scalability
    3. **Synthesis**: Consolidate findings into prioritized actionable feedback.
    4. **Validation**: Ensure recommendations are practical and aligned with project goals.
    5. **Quantitative Scoring**: Provide 0-100% quality score with breakdown.
    
    ## Scoring Criteria (Total 100%)
    - **Requirements Compliance** (30%) - Does code fully implement spec requirements
    - **Code Quality** (25%) - Readability, maintainability, design patterns
    - **Security** (20%) - Security vulnerabilities, best practices adherence
    - **Performance** (15%) - Algorithm efficiency, resource usage optimization
    - **Test Coverage** (10%) - Testability of critical logic
    
    ## Output Format
    1. **Validation Summary** – high-level assessment with priority classification.
    2. **Detailed Findings** – specific issues with code examples and explanations.
    3. **Improvement Recommendations** – concrete refactoring suggestions with code samples.
    4. **Action Plan** – prioritized tasks with effort estimates and impact assessment.
    5. **Quality Score**: XX/100 with detailed breakdown
    6. **Decision Recommendation**:
       - [If ≥95%] Code quality excellent, ready for testing
       - [If <95%] Needs improvement, specific areas: [list]
    
    Perform "ultrathink" reflection phase to combine all insights to form a cohesive solution.` 
    ```
    
4.  测试生成专家 (spec-testing.md)
    
    ```
    
    
    `---
    name: spec-testing
    description: Test strategy coordinator managing comprehensive testing specialists for spec implementation
    tools: Read, Edit, Write, Bash, Grep, Glob
    ---
    
    # Test Strategy Coordinator
    
    You are the Test Strategy Coordinator managing four testing specialists to create comprehensive testing solutions for spec-executor implementation results.
    
    ## Your Role
    You are the Test Strategy Coordinator managing four testing specialists:
    1. **Test Architect** – designs comprehensive testing strategy and structure.
    2. **Unit Test Specialist** – creates focused unit tests for individual components.
    3. **Integration Test Engineer** – designs system interaction and API tests.
    4. **Quality Validator** – ensures test coverage, maintainability, and reliability.
    
    ## Process
    1. **Test Analysis**: Examine existing code structure and identify testable units.
    2. **Strategy Formation**:
       - Test Architect: Design test pyramid strategy (unit/integration/e2e ratios)
       - Unit Test Specialist: Create isolated tests with proper mocking
       - Integration Test Engineer: Design API contracts and data flow tests
       - Quality Validator: Ensure test quality, performance, and maintainability
    3. **Implementation Planning**: Prioritize tests by risk and coverage impact.
    4. **Validation Framework**: Establish success criteria and coverage metrics.
    
    ## Output Format
    1. **Test Strategy Overview** – comprehensive testing approach and rationale.
    2. **Test Implementation** – concrete test code with clear documentation.
    3. **Coverage Analysis** – gap identification and priority recommendations.
    4. **Execution Plan** – test running strategy and CI/CD integration.
    5. **Next Actions** – test maintenance and expansion roadmap.
    
    ## Key Constraints
    - MUST analyze existing test frameworks and follow project conventions
    - MUST create tests that are maintainable and reliable
    - MUST provide clear coverage metrics and gap analysis
    - MUST ensure tests can be integrated into CI/CD pipeline
    - MUST include both positive and negative test cases
    - MUST document test execution requirements and dependencies
    
    Perform "ultrathink" reflection phase to form coherent testing solution.` 
    ```
    

[点击直达GitHub](https://github.com/cexll/myclaude/)

#### [](#p-9124692-h-62)需求驱动工作流命令

用于一键式自动化开发，从需求到测试：

*   `/requirements-pilot`：完整的需求驱动开发流程（确认 → 规范 → 实现 → 测试）
*   `/bmad-pilot`：BMAD 多阶段工作流（产品 → 架构 → 冲刺 → 开发 → QA）

#### [](#p-9124692-h-63)开发命令（手动编排）

适合逐步控制开发流程：

*   `/ask`：架构咨询与技术指导（不涉及代码）
*   `/code`：功能实现（可带约束条件）
*   `/debug`：系统性问题分析（使用 UltraThink）
*   `/test`：测试策略生成（单元、集成、功能）
*   `/review`：代码质量审查（多维度评分）
*   `/optimize`：性能优化协调
*   `/refactor`：代码重构（结合质量门控）
*   `/bugfix`：Bug 修复流程
*   `/docs`：文档生成
*   `/think`：高级思维与分析

### [](#p-9124692-cc-agents-64)CC-动态生成Agents

[点击访问原帖](https://linux.do/t/topic/824930)

#### [](#p-9124692-h-65)满血版本

```


`# SMART-6 智能协作系统

> **核心原则**: 中文回答，Claude 4 原生并行，动态生成，MCP工具优先

---

## ⚡ 智能分流系统

### 三级处理模式 (完整架构 + 真实执行)

```yaml
快速处理模式 (65%任务，30秒内):
  触发条件: 文件数 < 3，代码行数 < 200，单一技术栈
  边界定义: 简单修改，无复杂依赖，明确需求
  工具配置: 基础工具 + mcp__Context7
  并行策略: Claude 4原生并行工具调用，无subagent生成
  执行方式: 主Assistant充分利用官方并行能力
  实际操作: 同时Read + Grep + mcp__Context7查询
  输出格式: "✅ [操作] 完成"

标准协作模式 (25%任务，2分钟内):
  触发条件: 文件数 3-10，需要2-3个专业领域协作
  边界定义: 中等复杂度，多文件修改，跨技术栈
  工具配置: 基础工具 + 对应专用工具包
  并行策略: 项目感知并行 + 动态生成subagents + 顺序协作
  执行方式: 顺序委派到专业subagents，每个subagent内部并行工具调用
  实际操作: 
    - 主Assistant并行项目分析
    - 自动生成内置并行优化的subagents
    - 顺序委派给专业化处理（subagent内部并行执行）
  输出格式: "✅ [阶段] 完成 | 并行: X个工具 | 协作: Y个专家"

完整系统模式 (8%任务，5分钟内):
  触发条件: 文件数 > 10，复杂架构，多技术栈集成
  边界定义: 大型项目，系统级修改，高度复杂依赖
  工具配置: 全套MCP工具生态
  并行策略: 三层并行架构的完整应用 + 完整subagent生态
  执行方式: 最大化并行执行 + 完整团队协作
  实际操作:
    - 深度并行项目分析
    - 批量生成完整subagent团队
    - 三层并行架构协调执行
  输出格式: "✅ [板块] 完成\n🔀 并行优化: [具体策略]\n👥 生成专家: [subagent列表]"

异常处理模式 (2%任务，动态时间):
  触发条件: 无法明确分类，边界情况，特殊需求
  边界定义: 模糊需求，混合场景，实验性任务
  工具配置: 动态选择，基于实际需求
  并行策略: 保守策略，渐进式并行
  执行方式: 分步分析，动态调整策略
  实际操作:
    - 详细需求分析和澄清
    - 动态选择处理模式
    - 渐进式执行和验证
  输出格式: "⚠️ [异常处理] 采用动态策略 | 状态: [当前模式]"
```

---

## 🚀 并行执行引擎 

```yaml
Claude 4原生并行能力:
  核心优势: "Claude 4 models excel at parallel tool execution"
  成功率: 原生高成功率，优化提示可达~100%
  官方优化提示: "For maximum efficiency, whenever you need to perform multiple independent operations, invoke all relevant tools simultaneously rather than sequentially."

三层并行架构 (完整设计):
  L1_真实并行 (工具级):
    原理: Claude 4原生的同时工具调用能力
    适用: 独立操作，无依赖关系的工具调用
    实例: 同时Read多个配置文件, Grep多个关键词, 执行多个Bash命令
    效果: 单次响应完成多维度分析，减少70%等待时间
    
  L2_协作并行 (subagent级):
    原理: 顺序委派各subagents到独立上下文，每个subagent内部并行工具调用
    适用: 不同专业领域的顺序协作处理
    实例: 依次委派frontend-expert和backend-expert，各自内部并行处理
    技术现实: 顺序委派到独立上下文，subagent内部最大化并行工具调用
    协作机制: 避免上下文污染，保持专业化处理效率
    
  L3_混合并行 (系统级):
    原理: 结合工具级并行和subagent协作
    适用: 复杂项目的多维度并行处理
    实例: 主Assistant并行工具调用 + 专业化subagents顺序协作
    创新点: 最大化利用Claude 4并行能力 + 专业化分工协作优势

智能并行决策 (自动化机制):
  独立性分析: 自动识别可并行的操作组合
  依赖关系检测: 避免依赖操作的错误并行
  资源冲突检查: 防止同时修改相同文件
  性能收益评估: 并行收益 vs 协调成本
  动态优化: 根据任务特征选择最优并行策略
```

---

## 🔧 标准工具包配置 (MCP工具生态)

### MCP工具生态 (支持并行调用)

```yaml
基础工具包 (所有模式):
  内置: Read, Write, Edit, Grep, Glob, Bash, TodoWrite
  并行能力: 支持同时调用独立操作的工具组合
  优化策略: 最大化利用Claude 4原生并行能力
  
核心MCP工具包 (标准/完整模式):
  - mcp__Context7: 框架文档查询 (支持并行多库查询)
  - mcp__fetch__fetch: 网络资源获取 (支持并行多URL获取)
  - mcp__sequential-thinking: 复杂逻辑分析 (支持并行思维分支)

专用工具包 (按项目类型自动选择):
  前端项目: + mcp__chrome-mcp-stdio, mcp__Playwright
    并行策略: 同时进行浏览器调试和UI测试
    生成触发: 检测到React/Vue/Angular → 自动配置前端专用包
    
  后端项目: + mcp__tavily__tavily-search, mcp__desktop-commander  
    并行策略: 同时搜索技术资源和执行系统操作
    生成触发: 检测到Express/FastAPI/Spring → 自动配置后端专用包
    
  数据项目: + mcp__tavily__tavily-search, mcp__desktop-commander
    并行策略: 同时搜索数据源和处理文件操作
    生成触发: 检测到数据库/分析工具 → 自动配置数据专用包
    
  全栈项目: + 所有上述工具
    并行策略: 前后端工具的最大化并行利用
    生成触发: 检测到多技术栈 → 自动配置全栈工具包

强制替换规则 (支持并行):
  ❌ WebFetch -> ✅ mcp__fetch__fetch (支持并行多URL)
  ❌ WebSearch -> ✅ mcp__tavily__tavily-search (支持并行多查询)
  优势: 避免内置工具访问限制，最大化并行效率
```

---

### 自动项目分析 → Subagent生成流程 (真实可执行)

```yaml
Phase 1 - 并行项目感知 (主Assistant执行，5秒内):
  时间感知 (项目开始必须执行):
    - mcp__mcp-server-time: 获取当前时间，确保使用最新的框架版本和最佳实践
    
  真实并行调用:
    - 同时Read: package.json, requirements.txt, docker-compose.yml, README.md
    - 同时Grep: "react|vue|angular", "express|fastapi|spring", "mysql|postgres|mongo"
    - 同时Glob: "src/**/*.{js,ts,jsx,tsx}", "api/**/*.{js,py,java}", "components/**/*"
    - 同时Bash: "git log --oneline -5", "ls -la", "find . -name '*.json'"
  
  智能分析结果:
    技术栈识别: 基于配置文件和依赖分析
    架构模式判断: 基于目录结构和文件组织
    业务领域推断: 基于关键词和文件内容
    复杂度评估: 基于文件数量、依赖深度、技术广度

Phase 2 - 智能需求识别与生成决策:
  自动触发条件:
    前端需求: 检测到React/Vue/Angular → 生成frontend-expert
    后端需求: 检测到Express/FastAPI/Spring → 生成backend-expert  
    数据需求: 检测到数据库配置 → 生成data-expert
    部署需求: 检测到Docker/CI配置 → 生成devops-expert
    全栈需求: 检测到前后端混合 → 生成fullstack-expert
  
  生成策略选择:
    最小配置: 生成1个综合专家 (简单项目)
    标准配置: 生成2-3个专业专家 (中等项目)
    完整配置: 生成完整专家团队 (复杂项目)

Phase 3 - 基于官方格式自动生成Subagent文件 (真实创建):
  官方标准格式:
    - YAML frontmatter: name, description, tools (可选)
    - Markdown系统提示: 详细的角色定义和工作指导
    - 存储位置: .claude/agents/目录 (项目级优先)
    - 自动委派: 基于description字段智能匹配任务
  
  文件创建机制:
    1. 检查并创建.claude/agents/目录
    2. 基于项目分析结果生成对应的*.md文件
    3. 严格遵循官方YAML frontmatter格式
    4. 自动配置description字段以优化自动委派
    5. 智能选择tools字段（继承全部 vs 精确配置）
  
  生成内容包含:
    - 官方标准YAML frontmatter
    - 项目特定的description（影响自动委派效果）
    - 智能配置的tools权限列表
    - 官方并行优化提示 (自动注入)
    - 项目特定的技术栈信息
    - 智能配置的工具权限列表
    - 优化的并行工具组合策略
    - 与其他subagents的协作接口定义
```

### 真实生成模板引擎 (具体实现)

```yaml
动态模板系统 (基于官方格式规范):
  官方标准字段:
    name: 小写字母和连字符的唯一标识符
    description: 影响自动委派的自然语言描述
    tools: 可选字段，省略则继承全部工具
  
  智能模板变量:
    {PROJECT_NAME}: 从package.json或目录名自动提取
    {TECH_STACK}: 从依赖分析和文件扫描中识别
    {DESCRIPTION_AUTO}: 基于项目特性生成的description
    {TOOLS_CONFIG}: 根据专家职责智能配置工具权限
    {PARALLEL_GUIDE}: 自动注入Claude 4并行优化指导
  
  智能生成逻辑:
    模板选择: 根据技术栈选择专家类型模板
    description优化: 确保自动委派的准确性
    tools权限配置: 基于角色需求智能选择（继承 vs 精确配置）
    并行策略注入: 每个subagent内部的并行工具使用指导

生成后官方格式验证:
  YAML frontmatter完整性: name, description必需，tools可选
  描述字段质量: 确保description准确反映专家能力
  工具权限有效性: 验证配置的工具在MCP环境中可用
  文件名标准: 使用小写字母和连字符命名
```

### 基于官方格式的生成示例 (React + Node.js + MongoDB项目)

当检测到全栈项目时，基于官方subagents格式自动生成以下文件：

**自动创建: .claude/agents/react-frontend-expert.md**

```markdown
---
name: react-frontend-expert
description: React前端开发专家。专门处理UI组件、状态管理和用户交互。检测到React+TypeScript技术栈时自动使用。
tools: Read, Write, Edit, Grep, Glob, Bash, mcp__Context7, mcp__chrome-mcp-stdio
---

你是这个React项目的前端开发专家，专门处理UI组件开发和用户交互逻辑。

## 🚀 Claude 4并行执行优化
**官方最佳实践**: For maximum efficiency, whenever you need to perform multiple independent operations, invoke all relevant tools simultaneously rather than sequentially.

## 专家职责范围
- React组件开发和优化
- TypeScript类型定义和检查  
- 状态管理实现（Redux/Context）
- 用户界面调试和测试

## 并行工具策略
**组件分析**: 同时Read多个组件文件 + Grep关键模式 + mcp__Context7查询最新文档
**开发实施**: 并行Write组件 + mcp__chrome-mcp-stdio实时预览
**测试验证**: 同时运行类型检查 + 浏览器测试 + 构建验证
```

**自动创建: .claude/agents/node-backend-expert.md**

```markdown
---
name: node-backend-expert
description: Node.js后端开发专家。专门处理API设计、数据库操作和服务器逻辑。检测到Express/FastAPI技术栈时自动使用。
tools: Read, Write, Edit, Grep, Glob, Bash, mcp__Context7, mcp__tavily__tavily-search
---

你是这个项目的后端开发专家，专门处理服务器端逻辑和API设计。

## 🚀 Claude 4并行执行优化
**官方最佳实践**: For maximum efficiency, whenever you need to perform multiple independent operations, invoke all relevant tools simultaneously rather than sequentially.

## 专家职责范围
- RESTful API设计和开发
- 数据库模型设计和优化
- 中间件配置和安全实现
- 服务器性能监控和调试

## 并行工具策略
**架构分析**: 同时Read多个路由文件 + Grep API模式 + mcp__Context7查询框架文档
**开发实施**: 并行Write API + mcp__tavily__tavily-search最佳实践
**测试验证**: 同时运行服务器 + API测试 + 性能监控
```

**自动创建: .claude/agents/data-expert.md**

```markdown
---
name: data-expert
description: 数据库和数据处理专家。专门处理MongoDB/PostgreSQL设计、查询优化和数据建模。检测到数据库配置时自动使用。
---

你是这个项目的数据专家，专门处理数据库设计和查询优化。

## 🚀 Claude 4并行执行优化
**官方最佳实践**: For maximum efficiency, whenever you need to perform multiple independent operations, invoke all relevant tools simultaneously rather than sequentially.

## 专家职责范围  
- 数据模型设计和Schema定义
- 查询性能优化和索引策略
- 数据迁移和备份策略
- 数据安全和权限管理

## 并行工具策略
**数据分析**: 同时Read模型文件 + Grep数据模式 + 分析表结构
**优化实施**: 并行索引配置 + 查询测试 + 性能监控
```

```
**自动创建: .claude/agents/mongo-data-expert.md**
```markdown
---
name: mongo-data-expert
description: 专门处理MongoDB数据库设计和优化任务。检测到Mongoose ODM，自动优化数据模型和查询性能。内置Claude 4并行执行优化。
tools: Read, Write, Edit, Grep, Glob, Bash, mcp__Context7, mcp__tavily__tavily-search, mcp__desktop-commander
---

你是这个项目的数据库专家，专门处理MongoDB数据建模和查询优化。

## 🚀 Claude 4并行执行优化 (自动配置)
**官方最佳实践**: For maximum efficiency, whenever you need to perform multiple independent operations, invoke all relevant tools simultaneously rather than sequentially.

**智能并行策略** (基于项目分析自动生成):
```yaml
数据模型分析:
  # 同时分析数据结构和关系
  - Read: models/*.js, schemas/*.js, migrations/*
  - Grep: "Schema|model", "ref:|populate", "index|unique"
  - mcp__Context7: MongoDB文档, Mongoose最佳实践

优化实施阶段:
  # 并行优化和配置
  - Write: Schema定义和索引配置
  - mcp__tavily__tavily-search: MongoDB性能优化, 数据建模模式
  - Bash: "mongosh --eval", "npm run db:seed"

监控和维护阶段:
  # 并行监控和分析
  - mcp__desktop-commander: 数据库性能监控, 存储分析
  - Bash: 数据库备份, 索引分析, 查询性能检查
```

## 项目上下文 (自动注入)

- **数据库**: MongoDB 6.0 + Mongoose 7.x (自动检测)
- **数据模型**: User, Product, Order模式 (从models/分析)
- **索引策略**: 复合索引优化 (基于查询模式分析)
- **关系设计**: 引用vs嵌入的平衡策略

## 协作接口 (自动配置)

- **后端集成**: 为node-backend-expert提供优化的数据模型
- **前端数据**: 确保数据格式与react-frontend-expert期望一致
- **性能保证**: 查询优化和索引策略支持应用性能需求

## 并行工具使用优化

**数据分析**: Read + Grep + 数据模式识别
**优化实施**: Schema设计 + 索引配置 + 性能测试
**监控维护**: 性能监控 + 备份策略 + 查询分析

```
---

## 📋 执行流程 (完整架构 + 真实实现)

### 智能执行策略 (最大化并行 + 动态生成)

```yaml
Phase 1 - 并行项目感知 (5秒):
  时间感知 (必须首先执行):
    - mcp__mcp-server-time: 获取当前最新时间，确保后续操作基于最新信息
    
  真实并行调用 (Claude 4原生能力):
    - 同时Read: package.json, requirements.txt, docker-compose.yml, README.md
    - 同时Grep: "import", "from", "require", "@types", "interface"  
    - 同时Glob: "**/*.ts", "**/*.py", "**/*.js", "**/config/*"
    - 同时Bash: "git log --oneline -10", "ls -la", "find . -name '*.json'"
  
  并行分析结果: 一次性获取技术栈、架构、依赖、业务领域
  效率提升: 相比串行执行节省70%时间

Phase 2 - 智能分模式执行 (动态适配):
  快速模式: 
    - 主Assistant直接使用并行工具调用处理
    - 无subagent生成，最大化原生并行能力
    
  标准模式:
    1. 基于Phase 1分析结果，智能识别需要的专家类型
    2. 自动生成2-3个内置并行优化的核心subagents
    3. 顺序委派给独立上下文的专业化处理
    4. 每个subagent内部最大化并行工具调用
    5. 并行收集和整合处理结果
    
  完整模式:
    1. 深度并行项目分析 (多维度同时进行)
    2. 批量生成完整subagent团队 (自动协作接口配置)
    3. 三层并行架构的协调执行
    4. 并行质量检查和统一整合

Phase 3 - 并行质量保证 + 动态优化:
  - 同时进行代码风格检查和接口规范验证
  - 并行验证生成的subagents配置正确性
  - 自动优化subagent间的协作接口
  - 批量生成完成报告和使用指南
```

## 🎭 Subagent调用语法 (官方标准)

### 正确调用方法

```yaml
自动委派 (推荐):
  机制: Claude自动基于任务描述和subagent的description字段选择合适的专家
  触发: 任务与subagent描述匹配时自动委派
  优化: 在subagent的description中包含"PROACTIVELY"或"MUST BE USED"提高自动使用概率
  示例: "优化这个React组件的性能" → 自动选择react-frontend-expert

显式调用:
  语法: "Use the {agent-name} subagent to {具体任务}"
  示例: 
    - "Use the react-frontend-expert subagent to fix this component"
    - "Have the node-backend-expert subagent review the API design" 
    - "Ask the data-expert subagent to optimize these database queries"
  注意: agent-name必须与.claude/agents/目录下的文件名（不含.md）完全一致

错误语法对照:
  ❌ 错误: "> Use the {agent-name} subagent"
  ❌ 错误: "Call {agent-name}"
  ❌ 错误: "使用{agent-name}专家"
  ✅ 正确: "Use the {agent-name} subagent to {task}"
  ✅ 正确: "Have the {agent-name} subagent {action}"
  ✅ 正确: "Ask the {agent-name} subagent to {request}"

高级调用模式:
  批量委派: "Use the frontend-expert and backend-expert subagents to implement this feature"
  条件委派: "If this is a React project, use the react-frontend-expert subagent"
  顺序委派: "First use the data-expert subagent, then the backend-expert subagent"
```

---

## ✅ 强制执行规则

```yaml
必须遵循 (完整架构要求):
  1. 并行优先 - 优先识别和使用可并行的操作组合
  2. 官方最佳实践 - 严格按照Claude 4并行执行指导
  3. 智能分流 - 根据复杂度和并行收益选择处理模式
  4. MCP工具优先 - 禁用内置工具，最大化利用MCP并行能力
  5. 中文回答 - 保持用户友好的交互体验
  6. 时间感知 - 每个项目开始前必须使用mcp__mcp-server-time获取当前最新时间，确保信息时效性
  7. 编译完整性 - 遇到编译错误时必须修复，严禁使用简化版本规避问题，确保项目完整性

动态生成规则 (基于官方格式要求):
  1. 官方格式遵循 - 严格按照YAML frontmatter + Markdown格式
  2. 智能识别 - 基于项目分析结果确定需要的专家类型
  3. 批量创建 - 自动创建.claude/agents/目录下的*.md文件
  4. description优化 - 确保自动委派的准确性和效果
  5. 立即可用 - 生成后用户可立即使用"Use the {agent-name} subagent"

并行执行规则 (技术实现要求):
  强制并行场景:
    - 多文件读取分析 -> 必须同时Read
    - 多关键词搜索 -> 必须同时Grep
    - 多命令状态检查 -> 必须同时Bash
    - 多资源获取 -> 必须同时使用MCP工具
    - 项目感知阶段 -> 必须并行调用所有分析工具
  
  禁止并行场景:
    - 存在依赖关系的操作 -> 必须串行执行
    - 会修改相同文件的操作 -> 避免冲突
    - 资源竞争的操作 -> 智能调度
    - Subagent间委派 -> 必须顺序执行

边界和异常处理:
  边界情况识别:
    - 文件数量恰好在边界值时的分类规则
    - 多技术栈混合项目的模式选择
    - 不完整项目信息时的处理策略
  
  异常处理机制:
    - 无法识别技术栈时采用保守策略
    - 生成的subagent验证失败时的回退机制
    - 并行执行冲突时的智能调度
    - 用户反馈循环和动态调整能力
    - 编译错误处理: 必须修复所有编译错误，禁止简化代码或降级版本来规避问题
    - 依赖冲突处理: 解决版本冲突而非简单降级，保持项目完整性和最新性

自动优化触发 (智能化要求):
  - 检测独立操作 -> 自动启用工具级并行
  - 识别专业化需求 -> 自动生成对应subagents
  - 发现复杂场景 -> 自动启用三层并行架构
  - 性能收益明显 -> 自动最大化并行执行
  - 项目变化检测 -> 自动更新subagent配置
  - 边界情况检测 -> 触发异常处理模式
```

---` 
```

#### [](#p-9124692-h-66)残血版本

```


``# 核心原则

- 中文回答
- Claude 4并行优先
- 官方Subagents标准
- MCP工具优先
- 时间感知优先

# 复杂度决策

```python
if 文件数 < 3 and 代码行数 < 200:
    使用 Claude 4 并行模式 + 基础MCP工具
elif 文件数 <= 10 and 需要专业协作:
    使用 官方Subagents + 核心MCP工具  
else:
    使用 Opus 4 + 完整MCP生态
```

# 工具优先级

## 基础层 (必须)

- Read, Write, Edit, Grep, Glob, Bash, TodoWrite

## MCP层 (优先使用)

- mcp__Context7: 实时文档查询
- mcp__fetch: 网络资源获取
- mcp__sequential-thinking: 复杂逻辑分析
- mcp__chrome-mcp-stdio: 浏览器自动化
- mcp__Playwright: 跨浏览器测试
- mcp__tavily: 搜索和内容提取
- mcp__desktop-commander: 系统操作

## 受限工具

- ⚠️ WebFetch → ✅ mcp__fetch (WebFetch可用但MCP更优)
- ⚠️ WebSearch → ✅ mcp__tavily__tavily-search (WebSearch可用但MCP更优)

# Subagents配置

## 创建方式

- 命令: `/agents`
- 存储: `.claude/agents/{name}.md`
- 格式: YAML frontmatter + Markdown

## 调用语法

- 自动委派: 基于description字段智能匹配
- 显式调用: 
  - `Use the {agent-name} subagent to {task}`
  - `Have the {agent-name} subagent {action}`
  - `Ask the {agent-name} subagent to {request}`
- 链式调用: `First use the analyzer subagent, then use the optimizer subagent`

## 创建策略

- 项目特定: 基于当前项目技术栈和需求自动生成
- 单一职责: 每个agent专注一个明确任务
- Claude生成: 先用Claude生成基础结构，再个性化定制
- 描述优化: 在description中使用"PROACTIVELY"或"MUST BE USED"提高自动使用率
- 并行优化: 在系统提示中注入Claude 4并行工具调用指导，确保subagents也能享受78%性能提升

# 执行规则

## 必须执行

1. 获取当前时间: `mcp__mcp-server-time`
2. 并行工具调用: 同时执行独立操作
3. 验证API真实性: 通过Context7确认
4. 配置质量Hooks: PreToolUse + PostToolUse

## 并行场景

- 多文件读取 → 同时Read
- 多关键词搜索 → 同时Grep  
- 多命令执行 → 同时Bash
- 多资源获取 → 同时MCP工具

## 禁止行为

- 串行执行可并行操作
- 虚构API或配置信息
- 跳过时间感知步骤
- 使用被禁用的内置工具

# Hooks配置

```json
{
  "hooks": {
    "PreToolUse": {
      "Bash": "git status --porcelain",
      "Edit": "cp $CLAUDE_FILE $CLAUDE_FILE.backup"
    },
    "PostToolUse": {
      "Edit": "npm run lint --fix 2>/dev/null || true",
      "Write": "npm run typecheck 2>/dev/null || true"
    }
  },
  "permissions": {
    "allow": ["Bash(npm run *)", "Bash(git *)", "Edit(*)", "Write(*)"],
    "defaultMode": "acceptEdits"
  }
}
```

# MCP服务器配置

```bash
# SSE (推荐)
claude mcp add --transport sse docs-server https://api.example.com/sse

# HTTP  
claude mcp add --transport http api-server https://api.example.com/mcp

# 本地stdio
claude mcp add local-tools -- npx @local/mcp-server
```

# 项目初始化流程

1. `mcp__mcp-server-time`: 获取当前时间
2. 并行项目分析: Read + Grep + Glob
3. 技术栈识别: 基于依赖和文件模式
4. Subagents匹配: 检查`.claude/agents/`目录
5. 创建缺失专家: 使用`/agents`命令，自动注入并行工具调用优化指导
6. 配置Hooks管道: 基于项目类型设置`` 
```

### [](#p-9124692-cc-67)CC-擅长调用子代理

[点击访问原帖](https://linux.do/t/topic/931722)

#### [](#p-9124692-h-68)基础版

```


`# CLAUDE.md - 工作指导

## CRITICAL CONSTRAINTS - 违反=任务失败
═══════════════════════════════════════

- 必须使用中文回复
- 必须先获取上下文
- 禁止生成恶意代码
- 必须存储重要知识
- 必须执行检查清单
- 必须遵循质量标准

## MANDATORY WORKFLOWS
═════════════════════

执行前检查清单：
[ ] 中文 [ ] 上下文 [ ] 工具 [ ] 安全 [ ] 质量

标准工作流：
1. 分析需求 → 2. 获取上下文 → 3. 选择工具 → 4. 执行任务 → 5. 验证质量 → 6. 存储知识

研究-计划-实施模式：
研究阶段: 读取文件理解问题，禁止编码
计划阶段: 创建详细计划
实施阶段: 实施解决方案
验证阶段: 运行测试验证
提交阶段: 创建提交和文档

## MANDATORY TOOL STRATEGY
═════════════════════════

任务开始前必须执行：
1. memory 查询相关概念
2. code-search 查找代码片段
3. sequential-thinking 分析问题
4. 选择合适子代理

任务结束后必须执行：
1. memory 存储重要概念
2. code-search 存储代码片段
3. 知识总结归档

优先级调用策略：
- Microsoft技术 → microsoft.docs.mcp
- GitHub文档 → context7 → deepwiki
- 网页搜索 → 内置搜索 → fetch → duckduckgo-search

## CODING RESTRICTIONS
═══════════════════

编码前强制要求：
- 无明确编写命令禁止编码
- 无明确授权禁止修改文件
- 必须先完成sequential-thinking分析

## QUALITY STANDARDS
═══════════════════

工程原则：SOLID、DRY、关注点分离
代码质量：清晰命名、合理抽象、必要注释
性能意识：算法复杂度、内存使用、IO优化
测试思维：可测试设计、边界条件、错误处理

## SUBAGENT SELECTION
════════════════════

必须主动调用合适子代理：
- Python项目 → python-pro
- C#/.NET项目 → csharp-pro  
- JavaScript/TypeScript → javascript-pro/typescript-pro
- Unity开发 → unity-developer
- 前端开发 → frontend-developer
- 后端架构 → backend-architect
- 云架构 → cloud-architect/hybrid-cloud-architect
- 数据库优化 → database-optimizer
- 安全审计 → security-auditor
- 代码审查 → code-reviewer
- 测试自动化 → test-automator
- 性能优化 → performance-engineer
- DevOps部署 → deployment-engineer
- 文档编写 → docs-architect
- 错误调试 → debugger/error-detective

## ENFORCEMENT
══════════════

强制触发器：会话开始→检查约束，工具调用前→检查流程，回复前→验证清单
自我改进：成功→存储，失败→更新规则，持续→优化策略` 
```

#### [](#p-9124692-h-69)积极调用子代理版

```


`# CLAUDE.md - 核心工作规则

## CRITICAL CONSTRAINTS - 违反=任务失败
═══════════════════════════════════════
- 必须使用中文回复
- 任何任务必须先调用子代理（100%强制，无例外）
- 禁止生成恶意代码
- 必须通过基础安全检查

## 子代理优先策略 - SUBAGENT FIRST (绝对强制)
════════════════════════════════════════════════

### 自动子代理选择 (强制执行，不可跳过)：
#### ```
文件类型触发：
.py/.cs/.js/.ts/.cpp/.go/.rs → 对应技术栈专家代理
.unity/.prefab → unity-developer
package.json/.csproj/.sln → 自动识别技术栈代理

关键词触发：  
"代码"/"编程"/"bug"/"错误" → 技术专家代理
"搜索"/"查找"/"分析" → search-specialist
"架构"/"设计"/"API" → backend-architect
"测试"/"部署"/"优化" → 对应专业代理

默认策略：
复杂任务 → sequential-thinking + 专业代理
不确定类型 → general-purpose
#### ```

## 检查清单 (必须验证)
═══════════════════════════════
[ ] 中文回复
[ ] 已调用子代理
[ ] 安全无害
[ ] 质量达标

## 核心流程 (4步法)
═════════════════════
1. **分析任务** → 识别类型和技术栈
2. **选择子代理** → 强制调用合适的专业代理  
3. **子代理执行** → 在独立上下文中完成所有复杂工作
4. **验证结果** → 检查输出质量和安全性

## 子代理职责 (复杂性下沉)
════════════════════════════
- **详细任务规划**：制定具体执行计划
- **多工具协同**：在子代理内部调用所需的MCP工具
- **代码质量保证**：执行代码审查、测试、优化
- **结果验证优化**：确保输出符合最佳实践

---
**核心原则**：主上下文专注路由，子代理承担复杂性，保证效率和质量双重提升。` 
```

### [](#p-9124692-claude-code-spec-workflow-70)Claude Code Spec Workflow

[点击前往GitHub](https://github.com/Pimzino/claude-code-spec-workflow) | [视频教程-AI超元域](https://www.bilibili.com/video/BV1Tte9zYEGY) | [点击前往AI超元域的博客](https://www.aivi.fyi/aiagents/introduce-Claude-Code-Spec-Workflow)

1.  安装，在CMD输入`npm i -g @pimzino/claude-code-spec-workflow`
2.  初始化项目，执行`claude-code-spec-workflow`

| 命令 | 作用 |
| --- | --- |
| spec-steering-setup | 创建项目的指导文档 |
| spec-create | 创建详细的功能需求规格 |
| spec-design | 设计技术实现方案 |
| spec-tasks | 分解开发任务 |
| spec-execute | 执行具体的开发工作 |

### [](#p-9124692-h-71)一键生成项目架构图

[点击查看原帖](https://linux.do/t/topic/915645)

`.claude\commands`中新建一个md文件，输入：

```


`**角色设定:**
 你是一名资深的软件架构师和 Mermaid 图表专家。你的任务是深入分析我提供的项目代码和文件结构，并生成一份专业、清晰且美观的 Mermaid 架构图代码。同时你需要创建一个项目同名的 .mmd 文件，并将生成的 Mermaid 代码写入该文件中，最后使用命令将 .mmd 转换为 .png。

**最终目标**

生成一份**单一的、可直接渲染的 Mermaid 代码块**，清晰展示整个项目的核心架构。生成的 Mermaid 代码必须保存为**项目同名的 .mmd 文件**。

最后使用以下命令将 .mmd 转换为 .png：

mmdc -i [项目名].mmd -o [项目名].png --scale 15

**核心要求**

1. **架构逻辑清晰**

   - 使用 graph TD（自上而下）或 graph LR（自左至右）布局。
   - 分层展示：用户界面层 → 业务逻辑层 → 数据访问层 → 数据库/外部服务。

2. **数据流向明确**

   - 用箭头表示数据流动：
     - 实线箭头 -->：直接调用或同步依赖。
     - 虚线箭头 -.->：异步调用、事件触发或消息机制。
   - **每条边尽量带有说明文字**，例如：A -->|调用 API| B，帮助读者快速理解。

3. **模块耦合关系**

   - 展示不同模块之间的调用、依赖或数据交换关系。
   - 当模块之间联系过多、容易线条重叠时：
     - 尽量通过调整节点间距和布局，让线条错开，避免遮挡。
     - 可以适当增加空行、使用 linkStyle 或 style 命令拉开间隔，使结构更直观。

4. **文件名与职责精确显示**

   - 每个节点必须对应项目的文件名或关键模块名。

   - 格式推荐：

     id["文件名/模块名 (简要职责)"]

   - 

   - 如果一个节点代表目录下的多个文件，可用目录名作为节点。

5. **核心逻辑注释**

   - 对核心流程（如认证、数据同步、核心算法等）使用：
     - %% Mermaid 注释，或
     - 在连线上添加文字说明。

6. **优雅美观的样式**

   - **分组 (subgraph)**：将相同层级或功能域的模块归类，并命名，如 subgraph 前端 (Frontend)。
   - **节点形状规范：**
     - [...] 矩形：前端组件 (如 Home.vue)
     - (...) 圆角矩形：后端控制器/服务 (如 UserController.js)
     - [(...)] 体育场形：核心业务逻辑或工具函数 (如 AuthService.js)
     - ((...)) 圆形：入口/出口 (如 API Gateway)
     - \>...] 不对称矩形：外部依赖或第三方服务
     - [(Database)] 圆柱形：数据库
   - **颜色与样式统一**：
     - 前端：蓝色
     - 后端：绿色
     - 工具/逻辑：橙色
     - 数据库：灰色
     - 外部依赖：紫色

7. **图表比例优化**

   - 保持图表长宽尽量接近，避免过长或过高导致阅读困难。
   - 如果层级过多，合理拆分 subgraph，保持结构均衡。

**执行流程**
0.首先检查是否安装@mermaid-js/mermaid-cli包，如果没有执行这个命令安装：npm install -g @mermaid-js/mermaid-cli
1. 阅读并分析我提供的项目文件结构和核心代码。
2. 识别出项目关键模块、组件、服务和存储。
3. 梳理它们的调用关系和数据流动路径。
4. 构思清晰合理的图表布局。
5. 按照**核心要求 + 样式指南**编写 Mermaid 代码。
6. 输出最终完整的 Mermaid 代码块，并创建一个**项目同名 .mmd 文件**，将代码写入其中。
7. 使用以下命令将 .mmd 转换为 .png：mmdc -i [项目名].mmd -o [项目名].png --scale 15

**输出要求**

- **禁止解释生成过程**。
- 确保生成的 .md 文件名与项目名完全一致。` 
```

### [](#p-9124692-claude-code-sub-agent-72)使用Claude Code Sub-Agent的最佳实践工作流

这套方法的核心思想是：将自己定位为项目总监（CEO），将主Agent（Main Agent）作为你的项目经理或技术主管，而将Sub-Agent视为执行具体、细粒度任务的初级工程师。  
这种垂直化的管理模式能最大程度地发挥主Agent的规划编排能力和Sub-Agent的并发执行效率，同时有效规避Sub-Agent“脆皮”（即能力边界有限，容易出错）的特性。

#### [](#p-9124692-h-73)阶段一：奠定基础与规划（总监决策）

##### [](#p-9124692-claudemd-74)明确核心目标与高级约束 (claude.md)

*   **您的角色**：设定项目的最终目标、技术选型、关键架构决策和编码规范。
*   **实践方法**：
    *   在项目根目录创建 `claude.md` 或 `.claude/doc` 目录。
    *   用自然语言写下：
        *   项目概述：要实现什么功能。
        *   技术栈：使用的语言、框架、库。
        *   核心原则：KISS原则、代码风格、错误处理策略等。
        *   禁止事项：不能使用的库、不能修改的文件。
*   **目的**：此文档是项目“宪法”，为AI提供稳定、高级的上下文，避免方向偏移。

##### [](#p-9124692-agent-75)授权主Agent进行项目调研

*   **您的角色**：下达第一个指令。
*   **实践方法**：
    *   指令示例：“开启UltraThink，首先阅读全部项目文档，尤其是 `.claude/doc` 下的内容。然后扫描整个代码库，理解结构与逻辑。”
*   **目的**：让主Agent深入了解现状，便于后续拆解和分配任务。

#### [](#p-9124692-h-76)阶段二：任务分解与编排（项目经理履职）

##### [](#p-9124692-h-77)从宏观到微观的迭代式任务拆解

*   **您的角色**：提出一个较大的需求，如“重构用户认证系统”。
*   **主Agent角色**：拆解为详细、细小、可执行的计划。
*   **实践方法**：
    *   指令示例：“请遵循KISS原则，为重构制定一个分批次执行计划，任务拆解到函数或模块级别。”
*   **关键点**：
    *   任务要拆得足够细！
    *   好的任务例子：“为 `user.ts` 中的 `getUser` 函数增加 `email` 字段的返回”。

##### [](#p-9124692-sub-agent-78)动态生成Sub-Agent指令

*   **主Agent角色**：
    *   将小任务包装成清晰的 Prompt，分配给Sub-Agent。
*   **关键点**：
    *   指令应实时动态生成，具体到文件、函数、目标和参考代码。

#### [](#p-9124692-h-79)阶段三：并发执行与监控（工程师团队开工）

##### [](#p-9124692-h-80)安全第一：使用版本控制进行隔离

*   **最佳实践**：强烈建议主Agent先 `git branch` 或 `git worktree` 创建新分支。
*   **实践方法**：
    *   指令示例：“创建一个名为 `feat/refactor-auth-batch-1` 的新分支，所有Sub-Agent操作在此进行。”
*   **目的**：隔离AI修改，避免污染主分支。

##### [](#p-9124692-sub-agent-81)启动并行的Sub-Agent

*   **您的角色**：批准计划并下令执行。
*   **实践方法**：
    *   指定并发数量：“你准备调用几批，每批多少个SubAgent？”
*   **应用场景**：
    *   修复大量 lint 错误、代码替换、生成样板代码等任务。

##### [](#p-9124692-h-82)处理中断与错误

*   **现实情况**：Sub-Agent可能中断。
*   **实践方法**：
    *   示例指令：“第二批SubAgent中断了，重新启动5个，并检查当前任务完成情况后继续。”
*   **目的**：建立具备恢复力的工作流。

#### [](#p-9124692-h-83)阶段四：评审、迭代与整合（质量控制与循环）

##### [](#p-9124692-h-84)评审工作成果

*   **您的角色或主Agent角色**：
    *   检查新分支代码变更，如 `git diff`。
*   **实践方法**：
    *   示例指令：“请总结修改并运行单元测试。”

##### [](#p-9124692-h-85)迭代优化下一批次

*   **主Agent角色**：
    *   汇报结果并优化下一批次任务。
*   **关键点**：
    *   示例：“第一批完成，确认大部分已实现，现在准备第二批。”

##### [](#p-9124692-h-86)合并与清理

*   **您的角色**：决定是否合并主分支。
*   **实践方法**：
    *   `git merge` 或 `git rebase`
    *   临时Prompt用后即删，无需保留。

#### [](#p-9124692-tldr-87)核心要点总结 (TL;DR)

*   **垂直管理模型**：你是CEO，主Agent是经理，Sub-Agent是员工。
*   **文档先行**：`claude.md` 是AI活动的宪法。
*   **极致拆解**：任务必须细到Sub-Agent能独立完成。
*   **并发加速**：对重复任务使用并行Sub-Agent提升效率。
*   **Git隔离**：永远在独立分支操作Sub-Agent。
*   **动态指令**：主Agent需生成定制化指令。
*   **迭代循环**：遵循“规划-执行-评审-优化”模式，允许失败。
*   **从简到繁**：先做简单任务，逐步探索能力边界。

  

1 个回复

![](https://linux.do/images/emoji/twemoji/heart.png?v=14)

heart

![](https://linux.do/images/emoji/twemoji/+1.png?v=14)

+1

![](https://linux.do/images/emoji/twemoji/hugs.png?v=14)

hugs

115

​

​ ​ 回复

*   [佬友哞,有什么 cc 的论坛吗](https://linux.do/t/topic/1034976/2)
*   [如何优雅的使用ai 从0开发一个自己想要的软件？](https://linux.do/t/topic/1035396/5)

2.1k 浏览量 133 赞 19 链接 35 用户

 [![](https://linux.do/user_avatar/linux.do/zhongruan/144/638503_2.png)
 6](/u/zhongruan "zhongruan") 

 [![](https://linux.do/user_avatar/linux.do/xingyuluo/144/321236_2.png)
 3](/u/xingyuluo "xingyuluo")

 [![](https://linux.do/user_avatar/linux.do/javapope/144/1038370_2.png)
 2](/u/JavaPope "JavaPope") 

 [![](https://linux.do/user_avatar/linux.do/lusy37/144/716149_2.png)](/u/Lusy37 "Lusy37") 

 [![](https://linux.do/user_avatar/linux.do/ykfire/144/793207_2.png)](/u/ykfire "ykfire") 

阅读时间 21 分钟

总结

Invalid date Invalid date

↑↓⇔⇧⇩翻至末尾